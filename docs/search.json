[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Symulacja Monte Carlo",
    "section": "",
    "text": "Symulacja Monte Carlo to metoda używana do przewidywania prawdopodobieństwa wyniku, gdy występuje zmienność danych. Zmienność danych może być opisana w różny sposób. Najczęściej wykorzystuje się metody statystyczne i w przypadku, gdy dana wielkość posiada rozkład normalny, jego zmienność opisuje wartość średnia i odchylenie standardowe.\nEksperyment Monte Carlo polega na losowaniu dużej liczby danych z założonego zakresu zmienności poszczególnej wielkości modelowej. Następnie wykorzystuje się je do wygenerowania dużej liczby odpowiedzi modelu i w rezultacie, do oceny uzyskanego rozkładu wyników metodami statystycznymi.\nIdea metody Monte Carlo została naszkicowana na poniższym rysunku dla bardzo prostego modelu opisanego zwykłą funkcją kilku zmiennych niezależnych \\(x_i\\). W przedstawionym przykładzie założono dla uproszczenia, że rozkład każdej z nich jest zgodny z rozkładem Gaussa.\nSchemat losowania danych jest następujący:"
  },
  {
    "objectID": "index.html#model",
    "href": "index.html#model",
    "title": "Symulacja Monte Carlo",
    "section": "Model",
    "text": "Model\nModel opisany jest funkcją trzech zmiennych niezależnych \\(x_1, x_2, x_3\\):\n\\(y = a + b \\: sin(x_1) + c\\: x_2^2 + d \\: ln(x_3)\\),\ngdzie \\(a,\\: b,\\: c\\) i \\(d\\) są stałymi parametrami.\n\n\nSkrypt:\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm, ks_2samp, shapiro\nimport math\n\n# model\ndef funkcja_model(param, x):\n    a = param[0]\n    b = param[1]\n    c = param[2]\n    d = param[3]\n    # model\n    y = a + b*math.sin(x[0]) + c * (x[1] ** 2) +d * math.log(x[2])\n    return y"
  },
  {
    "objectID": "index.html#wykresy",
    "href": "index.html#wykresy",
    "title": "Symulacja Monte Carlo",
    "section": "Wykresy",
    "text": "Wykresy\nFunkcja ‘wykresy’ kreśli histogram, rozkład gęstości prawdopodobieństwa i dystrybuantę każdej danej. Dla uproszczenia założono rozkłady normalne.\n\n\nSkrypt:\ndef wykresy(i, x, sd):\n        plt.subplot(1, 3, 1)\n        plt.hist(np.random.normal(x[i], sd[i], 10000), bins=30, alpha=0.7, color=\"#54698a\")\n        plt.xlabel(f\"x{i+1}\")\n        plt.ylabel(\"częstość\")\n        plt.title(\"Histogram\")\n\n        xx = np.linspace(x[i] - 4 * sd[i], x[i] + 4 * sd[i], 100)\n        yy = norm.pdf(xx, x[i], sd[i])\n        plt.subplot(1, 3, 2)\n        plt.plot(xx, yy, lw=2, color=\"#54698a\")\n        plt.xlabel(f\"x{i+1}\")\n        plt.ylabel(\"gęstość prawdopodobieństwa\")\n        plt.title(f\"Rozkład x{i+1}\")\n\n        yy = norm.cdf(xx, x[i], sd[i])\n        plt.subplot(1, 3, 3)\n        plt.plot(xx, yy, lw=2, color=\"#54698a\")\n        plt.xlabel(f\"x{i+1}\")\n        plt.ylabel(\"prawdopodobieństwo skumulowane\")\n        plt.title(\"Dystrybuanta\")\n        plt.show()"
  },
  {
    "objectID": "index.html#monte-carlo",
    "href": "index.html#monte-carlo",
    "title": "Symulacja Monte Carlo",
    "section": "Monte Carlo",
    "text": "Monte Carlo\nFunkcja realizująca eksperyment Monte Carlo. Parametry formalne: n - liczba zmiennych \\(x_i\\), nn - liczba losowań, x - wartości średnie danych, sd - ich odchylenia standardowe, parametry - parametry funkcji opisującej model. Funkcja wykorzystuje generator liczb losowych i funkcję odwrotną dystrybuanty.\n\n\nSkrypt:\ndef monte_carlo(n, nn, x, sd, parametry):\n    np.random.seed(7)\n    y = np.zeros(nn)\n    for i in range(nn):\n        los_x = np.zeros(n)\n        for j in range(n):\n            los_x[j] = norm.ppf(np.random.rand(), x[j], sd[j])\n        y[i] = funkcja_model(parametry, los_x)\n    return y"
  },
  {
    "objectID": "index.html#rozkłady-danych",
    "href": "index.html#rozkłady-danych",
    "title": "Symulacja Monte Carlo",
    "section": "Rozkłady danych",
    "text": "Rozkłady danych\nRozkłady danych wejściowych.\n\n\nSkrypt:\nfor i in range(n):\n    wykresy(i, x, sd)\n\n\n\n\n\n\n\n\nRysunek 1: Rozkład wielkości x1\n\n\n\n\n\n\n\n\n\n\n\nRysunek 2: Rozkład wielkości x2\n\n\n\n\n\n\n\n\n\n\n\nRysunek 3: Rozkład wielkości x3"
  },
  {
    "objectID": "index.html#wyniki-symulacji-monte-carlo",
    "href": "index.html#wyniki-symulacji-monte-carlo",
    "title": "Symulacja Monte Carlo",
    "section": "Wyniki symulacji Monte Carlo",
    "text": "Wyniki symulacji Monte Carlo\n\n\nSkrypt:\nnn = 100000  # liczba losowań\n\ny = monte_carlo(n, nn, x, sd, parametry)  # symulacja Monte Carlo\n\n\nWszystkie wyniki obliczeń modelu przedstawiono na rys. Rysunek 4. Poniżej wyznaczono ich wartość średnią i odchylenie standardowe.\n\n\nSkrypt:\nplt.scatter(range(len(y)), y, s=0.5, color=\"#54698a\")\nplt.xlabel(\"nr losowania\")\nplt.title(\"Wynik zbiorczy symulacji Monte Carlo\")\nplt.show()\n\ny_av = np.mean(y)\nsd_y = np.std(y)\n\nprint(\"Uzyskana wartość średnia y_av = \", round(y_av,2))\nprint(\"Odchylenie standardowe sd_y = \", round(sd_y,2))\n\n\n\n\n\n\n\n\nRysunek 4: Wyniki losowań w symulacji Monte Carlo\n\n\n\n\n\nUzyskana wartość średnia y_av =  682.43\nOdchylenie standardowe sd_y =  44.98"
  },
  {
    "objectID": "index.html#rozkład-wielkości-wynikowej",
    "href": "index.html#rozkład-wielkości-wynikowej",
    "title": "Symulacja Monte Carlo",
    "section": "Rozkład wielkości wynikowej",
    "text": "Rozkład wielkości wynikowej\nRysunek 5 przedstawia histogram i wykres kwantylowy \\(y\\) w celu wizualnej oceny rozkładu wyniku.\n\nHistogram i wykres kwantylowy\nHistogram pozwala ocenić symetryczność rozkładu, a wykres kwantylowy zgodność z rozkładem normalnym.\n\n\nSkrypt:\nplt.subplot(1, 2, 1)\nplt.hist(y, bins=30, color=\"#54698a\", alpha=0.7)\nplt.title(\"Histogram y\")\nplt.ylabel(\"częstość\")\nplt.xlabel(\"y\")\n\nyy = (y - y_av) / sd_y  # standaryzacja rozkładu\n\nplt.subplot(1, 2, 2)\nplt.scatter(np.sort(norm.ppf(np.linspace(0.01, 0.99, len(yy)))), np.sort(yy), s=0.5, color=\"#54698a\")\nplt.title('Wykres kwantylowy Q-Q')\nplt.xlabel('kwantyle rozkładu normalnego')\nplt.ylabel('kwantyle rozkładu y')\nplt.plot([min(yy), max(yy)], [min(yy), max(yy)], color='#96cdf2')\nplt.show()\n\n\n\n\n\n\n\n\nRysunek 5: Wizualne sprawdzenie normalności rozkładu y\n\n\n\n\n\n\n\nSprawdzanie normalności rozkładu y\nWynik \\(y\\) liczy sobie 100 000 elementów, więc do oceny normalności jego rozkładu zastosowano test Kołmogorowa-Smirnowa.\n\n\nSkrypt:\n# test Kołmogorowa-Smirnowa\nksx = ks_2samp(y, np.random.normal(y_av, sd_y, len(y)))\nksxp = ksx.pvalue\nprint(\"prawdopodobieństwo p_value = \", round(ksx.pvalue,4))\n\nif ksxp &lt; 0.05:\n    print(\"\\nWedług testu Kołmogorowa-Smirnowa rozkład wielkości y nie jest normalny,\\nponieważ prawdopodobieństwo błędnego zanegowania jego normalności \\np_value jest &lt; 0.05. \")\nelse:\n    print(\"Według testu Kołmogorowa-Smirnowa rozkład wielkości y jest normalny (nie da się zaprzeczyć normalności rozkładu)\\n\\n\")\n\n# test Shapiro-Wilka\nif nn &lt;= 5000:\n    swx = shapiro(y)\n    print(swx)\n\n    swxp = swx.pvalue\n\n    if swxp &lt; 0.05:\n        print(\"Według testu Shapiro-Wilka rozkład wielkości y nie jest normalny\\n\\n\")\n    else:\n        print(\"Według testu Shapiro-Wilka rozkład wielkości y jest normalny (nie da się zaprzeczyć normalności rozkładu)\\n\\n\")\n\n\nprawdopodobieństwo p_value =  0.004\n\nWedług testu Kołmogorowa-Smirnowa rozkład wielkości y nie jest normalny,\nponieważ prawdopodobieństwo błędnego zanegowania jego normalności \np_value jest &lt; 0.05. \n\n\n\n\nRozkład y\nRysunek 6 przedstawia uzyskany rozkład gęstości prawdopodobieństwa \\(y\\) i jego dystrybuantę.\n\n\nSkrypt:\nplt.subplot(1, 2, 1)\nd = np.histogram(y, bins=50, density=True)\nplt.title(\"Rozkład y\")\nplt.xlabel(\"y\")\nplt.ylabel(\"gęstość prawdopodobieństwa\")\nplt.plot(d[1][:-1], d[0], color=\"#54698a\", lw=2)\n\nplt.subplot(1, 2, 2)\nplt.plot(d[1][:-1], np.cumsum(d[0]) / max(np.cumsum(d[0])), lw=2, color=\"#54698a\")\nplt.xlabel(\"y\")\nplt.ylabel(\"prawdopodobieństwo skumulowane\")\nplt.title(\"Dystrybuanta\")\nplt.show()\n\n\n\n\n\n\n\n\nRysunek 6: Rozkład wielkości y\n\n\n\n\n\n\n\nMediana, skośność i kurtoza\nW celu dodatkowej oceny rozbieżności z rozkładem normalnym wyznaczono medianę, skośność i kurtozę \\(y\\).\n\n\nSkrypt:\nfrom scipy.stats import skew\nfrom scipy.stats import kurtosis\n\n\nmed = np.median(y,  axis=0)\nprint(\"mediana = \", round(med,2))\n\nsk = skew(y, axis=0, bias=True)\nprint(\"skośność = \", round(sk,5))\n\nkurt = kurtosis(y, fisher=True, axis=0, bias=True) # kurtoza = 0 dla rozkłądu Gaussa\nprint(\"kurtoza = \", round(kurt,5))\n\nq_025 = np.quantile(y, 0.025)\nq_975 = np.quantile(y, 0.975)\n\nprint(\"kwantyl 0.025 = \", round(q_025,2))\nprint(\"kwantyl 0.975 = \", round(q_975,2))\n\n\nmediana =  681.76\nskośność =  0.08682\nkurtoza =  0.01324\nkwantyl 0.025 =  596.13\nkwantyl 0.975 =  771.98"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Jest to przykład prostej symulacji Monte Carlo, napisanej w Pythonie, w Quarto RStudio."
  }
]